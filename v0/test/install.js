// Generated by CoffeeScript 1.6.2
var expect, fs, install, path, rimraf;

expect = require('expect.js');

fs = require('fs');

install = require('../lib/commands/install');

rimraf = require('rimraf');

path = require('path');

describe('install', function() {
  var clean, cwd, noLocalnoSourceJson, noLocalyaSourceJson, testDir, yaLocalnoSourceJson, yaLocalyaSourceJson;

  cwd = process.cwd();
  testDir = "" + __dirname + "/install_test";
  process.env['HOME'] = testDir;
  noLocalnoSourceJson = {
    src: "../repos/without_json/"
  };
  yaLocalnoSourceJson = {
    src: "../repos/without_json/",
    root: "some_folder/"
  };
  noLocalyaSourceJson = {
    src: "../repos/with_json/"
  };
  yaLocalyaSourceJson = {
    src: "../repos/with_json/",
    root: "some_folder/"
  };
  clean = function(done) {
    return rimraf(testDir, function(err) {
      if (err) {
        throw new Error('Unable to remove install directory');
      }
      return typeof done === "function" ? done() : void 0;
    });
  };
  beforeEach(function(done) {
    process.chdir(cwd);
    return clean(function() {
      return fs.mkdir(testDir, function(err) {
        if (err) {
          throw err;
        }
        process.chdir(testDir);
        return typeof done === "function" ? done() : void 0;
      });
    });
  });
  after(function(done) {
    process.chdir(cwd);
    return clean(done);
  });
  it('has a line function', function(done) {
    expect(!!install.line).to.be(true);
    return done();
  });
  describe('events', function() {
    it('emits an end event', function(done) {
      return install([noLocalnoSourceJson]).on('error', function(err) {
        throw err;
      }).on('end', function(status) {
        expect(status).to.be(0);
        return done();
      });
    });
    return it('emits data events', function(done) {
      return install([noLocalnoSourceJson]).on('error', function(err) {
        throw err;
      }).on('data', function(data) {
        return expect(data).to.be.ok();
      }).on('end', function(status) {
        expect(status).to.be(0);
        return done();
      });
    });
  });
  describe('without source parachute.json', function() {
    it('saves dependencies into current working directory without root', function(done) {
      return install([noLocalnoSourceJson]).on('error', function(err) {
        throw err;
      }).on('end', function(status) {
        expect(fs.existsSync('should-copy.txt')).to.be(true);
        expect(fs.existsSync('css/core.css')).to.be(true);
        expect(fs.existsSync('.git')).to.be(false);
        return done();
      });
    });
    return it('saves dependencies into root', function(done) {
      return install([yaLocalnoSourceJson]).on('error', function(err) {
        throw err;
      }).on('end', function(status) {
        expect(fs.existsSync('some_folder/should-copy.txt')).to.be(true);
        expect(fs.existsSync('some_folder/css/core.css')).to.be(true);
        expect(fs.existsSync('some_folder/.git')).to.be(false);
        return done();
      });
    });
  });
  describe('with source json components option', function() {
    it('saves specified components in current working directory without root', function(done) {
      return install([noLocalyaSourceJson]).on('error', function(err) {
        throw err;
      }).on('end', function(status) {
        expect(fs.existsSync('css/shared/core.css')).to.be(true);
        expect(fs.existsSync('should-not-copy.txt')).to.be(false);
        expect(fs.existsSync('parachute.json')).to.be(false);
        expect(fs.existsSync('.git')).to.be(false);
        return done();
      });
    });
    return it('saves specified components into root', function(done) {
      return install([yaLocalyaSourceJson]).on('error', function(err) {
        throw err;
      }).on('end', function(status) {
        expect(fs.existsSync('some_folder/css/shared/core.css')).to.be(true);
        expect(fs.existsSync('some_folder/should-not-copy.txt')).to.be(false);
        expect(fs.existsSync('some_folder/parachute.json')).to.be(false);
        expect(fs.existsSync('some_folder/.git')).to.be(false);
        return done();
      });
    });
  });
  describe('with local components option', function() {
    it('saves specified components listed as strings', function(done) {
      var json;

      json = noLocalyaSourceJson;
      json.components = ['css/core.css'];
      return install([json]).on('error', function(err) {
        throw err;
      }).on('end', function(status) {
        expect(fs.existsSync('core.css')).to.be(true);
        expect(fs.existsSync('should-not-copy.txt')).to.be(false);
        return done();
      });
    });
    return it('saves specified components listed as objects', function(done) {
      var json;

      json = noLocalyaSourceJson;
      json.components = [
        {
          src: 'css/core.css',
          dest: 'css/shared/'
        }
      ];
      return install([json]).on('error', function(err) {
        throw err;
      }).on('end', function(status) {
        expect(fs.existsSync('css/shared/core.css')).to.be(true);
        expect(fs.existsSync('css/shared/should-not-copy.txt')).to.be(false);
        return done();
      });
    });
  });
  return describe('scripts', function() {
    return it('runs install and resolve scripts', function(done) {
      var scripts;

      scripts = {
        preresolve: 'touch preresolve_script.txt',
        postresolve: 'touch postresolve_script.txt',
        preinstall: 'touch preinstall_script.txt',
        postinstall: 'touch postinstall_script.txt'
      };
      expect(fs.existsSync('preresolve_script.txt')).to.be(false);
      expect(fs.existsSync('postresolve_script.txt')).to.be(false);
      expect(fs.existsSync('preinstall_script.txt')).to.be(false);
      expect(fs.existsSync('postinstall_script.txt')).to.be(false);
      return install([noLocalnoSourceJson], {
        scripts: scripts
      }).on('error', function(err) {
        throw err;
      }).on('end', function(status) {
        return setTimeout(function() {
          expect(fs.existsSync('preresolve_script.txt')).to.be(true);
          expect(fs.existsSync('postresolve_script.txt')).to.be(true);
          expect(fs.existsSync('preinstall_script.txt')).to.be(true);
          expect(fs.existsSync('postinstall_script.txt')).to.be(true);
          return done();
        }, 20);
      });
    });
  });
});
