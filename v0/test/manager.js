// Generated by CoffeeScript 1.6.2
var Dependency, EventEmitter, Manager, expect, fs, rimraf, sinon;

EventEmitter = require('events').EventEmitter;

Manager = require('../lib/core/manager');

Dependency = require('../lib/core/dependency');

fs = require('fs');

expect = require('expect.js');

rimraf = require('rimraf');

sinon = require('sinon');

describe('Manager', function() {
  var clean, config, cwd, testDir;

  cwd = process.cwd();
  testDir = "" + __dirname + "/install_test";
  config = {
    dependencies: [
      {
        src: 'git@foo.com:bar/baz.git'
      }, {
        src: 'git@bar.com:baz/foo.git'
      }
    ]
  };
  process.env['HOME'] = testDir;
  clean = function(done) {
    return rimraf(testDir, function(err) {
      if (err) {
        throw new Error('Unable to remove install directory');
      }
      return typeof done === "function" ? done() : void 0;
    });
  };
  beforeEach(function(done) {
    process.chdir(cwd);
    clean(function() {
      return fs.mkdir(testDir, function(err) {
        if (err) {
          throw err;
        }
        process.chdir(testDir);
        return typeof done === "function" ? done() : void 0;
      });
    });
    return this.manager = new Manager(config.dependencies);
  });
  after(function(done) {
    process.chdir(cwd);
    return clean(done);
  });
  describe('instance variables', function() {
    it('sets the dependencies on config', function(done) {
      expect(this.manager.config.dependencies).to.eql(config.dependencies);
      return done();
    });
    return it('creates a dependencies variable of Dependency objects', function(done) {
      var i, _, _i, _len, _ref;

      expect(this.manager.dependencies).to.have.length(2);
      _ref = this.manager.dependencies;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        _ = _ref[i];
        expect(this.manager.dependencies[i]).to.be.a(Dependency);
        expect(this.manager.dependencies[i].src).to.be(config.dependencies[i].src);
      }
      return done();
    });
  });
  describe('#resolve', function() {
    it('emits a resolved event', function(done) {
      sinon.stub(this.manager.dependencies[0], 'cache', function() {
        return {
          then: function(cb) {
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      });
      sinon.stub(this.manager.dependencies[1], 'cache', function() {
        return {
          then: function(cb) {
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      });
      return this.manager.on('error', function(err) {
        throw err;
      }).on('resolved', function(status) {
        expect(status).to.be(0);
        return done();
      }).resolve();
    });
    it('caches dependencies', function(done) {
      var stub1, stub2;

      sinon.stub(this.manager.dependencies[0], 'isCached', function() {
        return false;
      });
      sinon.stub(this.manager.dependencies[1], 'isCached', function() {
        return false;
      });
      stub1 = sinon.stub(this.manager.dependencies[0], 'cache', function() {
        return {
          then: function(cb) {
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      });
      stub2 = sinon.stub(this.manager.dependencies[1], 'cache', function() {
        return {
          then: function(cb) {
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      });
      this.manager.on('error', function(err) {
        throw err;
      }).resolve();
      expect(stub1.calledOnce).to.be(true);
      expect(stub2.calledOnce).to.be(true);
      return done();
    });
    it('updates already cached dependencies', function(done) {
      var manager, stubCache1, stubCache2, stubUpdate1, stubUpdate2;

      manager = new Manager(config.dependencies, {
        update: true
      });
      sinon.stub(manager.dependencies[0], 'isCached', function() {
        return true;
      });
      sinon.stub(manager.dependencies[1], 'isCached', function() {
        return true;
      });
      stubCache1 = sinon.stub(this.manager.dependencies[0], 'cache', function() {
        return {
          then: function(cb) {
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      });
      stubCache2 = sinon.stub(this.manager.dependencies[1], 'cache', function() {
        return {
          then: function(cb) {
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      });
      stubUpdate1 = sinon.stub(manager.dependencies[0], 'update', function(cb) {
        return typeof cb === "function" ? cb() : void 0;
      });
      stubUpdate2 = sinon.stub(manager.dependencies[1], 'update', function(cb) {
        return typeof cb === "function" ? cb() : void 0;
      });
      manager.on('error', function(err) {
        throw err;
      }).resolve();
      expect(stubCache1.calledOnce).to.be(false);
      expect(stubCache2.calledOnce).to.be(false);
      expect(stubUpdate1.calledOnce).to.be(true);
      expect(stubUpdate2.calledOnce).to.be(true);
      return done();
    });
    return it('runs resolve scripts', function(done) {
      var cacheFn, manager, postresolve, preresolve, resolvedCount, runScriptStub, scripts;

      resolvedCount = 0;
      preresolve = false;
      postresolve = false;
      scripts = {
        preresolve: 'foo',
        postresolve: 'bar'
      };
      manager = new Manager(config.dependencies, {
        scripts: scripts
      });
      cacheFn = function() {
        return {
          then: function(cb) {
            resolvedCount++;
            return typeof cb === "function" ? cb() : void 0;
          }
        };
      };
      sinon.stub(manager.dependencies[0], 'isCached', function() {
        return false;
      });
      sinon.stub(manager.dependencies[1], 'isCached', function() {
        return false;
      });
      sinon.stub(manager.dependencies[0], 'cache', cacheFn);
      sinon.stub(manager.dependencies[1], 'cache', cacheFn);
      runScriptStub = sinon.stub(manager, 'runScript', function(name) {
        if (resolvedCount === 0 && name === 'preresolve') {
          preresolve = true;
        }
        if (resolvedCount === 2 && name === 'postresolve') {
          return postresolve = true;
        }
      });
      return manager.on('error', function(err) {
        throw err;
      }).on('resolved', function() {
        return setTimeout(function() {
          expect(runScriptStub.calledWith('preresolve')).to.be(true);
          expect(runScriptStub.calledWith('postresolve')).to.be(true);
          expect(preresolve).to.be(true);
          expect(postresolve).to.be(true);
          return done();
        }, 20);
      }).resolve();
    });
  });
  describe('#install', function() {
    it('emits an installed event', function(done) {
      var dependency, _i, _len, _ref;

      _ref = this.manager.dependencies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dependency = _ref[_i];
        sinon.stub(dependency, 'copy', function(cb) {
          return typeof cb === "function" ? cb() : void 0;
        });
      }
      return this.manager.on('error', function(err) {
        throw err;
      }).on('installed', function(status) {
        expect(status).to.be(0);
        return done();
      }).install();
    });
    it('copies dependencies', function(done) {
      var stub1, stub2;

      stub1 = sinon.stub(this.manager.dependencies[0], 'copy', function(cb) {
        return typeof cb === "function" ? cb() : void 0;
      });
      stub2 = sinon.stub(this.manager.dependencies[1], 'copy', function(cb) {
        return typeof cb === "function" ? cb() : void 0;
      });
      this.manager.on('error', function(err) {
        throw err;
      }).install();
      expect(stub1.calledOnce).to.be(true);
      expect(stub2.calledOnce).to.be(true);
      return done();
    });
    return it('runs install scripts', function(done) {
      var copyFn, installCount, manager, postinstall, preinstall, runScriptStub, scripts;

      installCount = 0;
      preinstall = false;
      postinstall = false;
      scripts = {
        preinstall: 'foo',
        postinstall: 'bar'
      };
      manager = new Manager(config.dependencies, {
        scripts: scripts
      });
      copyFn = function(cb) {
        installCount++;
        return typeof cb === "function" ? cb() : void 0;
      };
      sinon.stub(manager.dependencies[0], 'copy', copyFn);
      sinon.stub(manager.dependencies[1], 'copy', copyFn);
      runScriptStub = sinon.stub(manager, 'runScript', function(name) {
        if (installCount === 0 && name === 'preinstall') {
          preinstall = true;
        }
        if (installCount === 2 && name === 'postinstall') {
          return postinstall = true;
        }
      });
      return manager.on('error', function(err) {
        throw err;
      }).on('installed', function() {
        return setTimeout(function() {
          expect(runScriptStub.calledWith('preinstall')).to.be(true);
          expect(runScriptStub.calledWith('postinstall')).to.be(true);
          expect(preinstall).to.be(true);
          expect(postinstall).to.be(true);
          return done();
        }, 20);
      }).install();
    });
  });
  describe('#update', function() {
    it('emits an updated event', function(done) {
      var dependency, _i, _len, _ref;

      _ref = this.manager.dependencies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dependency = _ref[_i];
        sinon.stub(dependency, 'update', function(cb) {
          return typeof cb === "function" ? cb() : void 0;
        });
      }
      return this.manager.on('error', function(err) {
        throw err;
      }).on('updated', function(status) {
        expect(status).to.be(0);
        return done();
      }).update();
    });
    return it('updates dependencies', function(done) {
      var stub1, stub2;

      stub1 = sinon.stub(this.manager.dependencies[0], 'update', function(cb) {
        return typeof cb === "function" ? cb() : void 0;
      });
      stub2 = sinon.stub(this.manager.dependencies[1], 'update', function(cb) {
        return typeof cb === "function" ? cb() : void 0;
      });
      this.manager.on('error', function(err) {
        throw err;
      }).update();
      expect(stub1.calledOnce).to.be(true);
      expect(stub2.calledOnce).to.be(true);
      return done();
    });
  });
  return describe('#runScript', function() {
    return it('executes the script name', function(done) {
      var manager;

      manager = new Manager(config.dependencies, {
        scripts: {
          foo: "pwd"
        }
      });
      return manager.on('error', function(err) {
        throw err;
      }).once('data', function(data) {
        expect(data.toString()).to.contain(process.env.HOME);
        return done();
      }).runScript('foo');
    });
  });
});
