// Generated by CoffeeScript 1.6.2
var Dependency, expect, fs, path, rewire, rimraf, sinon, timekeeper;

rewire = require('rewire');

Dependency = rewire('../lib/core/dependency');

fs = require('fs');

expect = require('expect.js');

rimraf = require('rimraf');

path = require('path');

sinon = require('sinon');

timekeeper = require('timekeeper');

describe('Dependency', function() {
  var clean, cwd, remoteDependency, testDir;

  cwd = process.cwd();
  remoteDependency = 'git@foo.com:bar/baz.git';
  testDir = "" + __dirname + "/install_test";
  process.env['HOME'] = testDir;
  clean = function(done) {
    return rimraf(testDir, function(err) {
      if (err) {
        throw new Error('Unable to remove install directory');
      }
      return typeof done === "function" ? done() : void 0;
    });
  };
  beforeEach(function(done) {
    process.chdir(cwd);
    return clean(function() {
      return fs.mkdir(testDir, function(err) {
        if (err) {
          throw err;
        }
        process.chdir(testDir);
        return typeof done === "function" ? done() : void 0;
      });
    });
  });
  after(function(done) {
    process.chdir(cwd);
    return clean(done);
  });
  describe('instance variables', function() {
    it('sets the source URL when remote', function(done) {
      var dependency;

      dependency = new Dependency(remoteDependency);
      expect(dependency.src).to.eql(remoteDependency);
      return done();
    });
    it('sets the source URL when local', function(done) {
      var dependency;

      dependency = new Dependency('../localDir/project');
      expect(dependency.src).to.eql(path.resolve('../localDir/project'));
      return done();
    });
    it('sets the name of the dependency', function(done) {
      var dependency;

      dependency = new Dependency(remoteDependency);
      expect(dependency.name).to.eql('bar-baz');
      return done();
    });
    it('sets the dependency cache directory', function(done) {
      var dependency;

      dependency = new Dependency(remoteDependency);
      expect(dependency.cacheDir).to.eql("" + process.env['HOME'] + "/.parachute/bar-baz");
      return done();
    });
    it('sets the dependency destination directory', function(done) {
      var dependencyWithDirectory, dependencyWithoutDirectory;

      dependencyWithoutDirectory = new Dependency(remoteDependency);
      dependencyWithDirectory = new Dependency(remoteDependency, {
        root: 'css'
      });
      expect(dependencyWithoutDirectory.root).to.eql(process.cwd());
      expect(dependencyWithDirectory.root).to.eql('css');
      return done();
    });
    it('sets whether the dependency source is remote', function(done) {
      var dependencyLocal, dependencyRemoteHttp, dependencyRemoteSsh;

      dependencyRemoteSsh = new Dependency(remoteDependency);
      dependencyRemoteHttp = new Dependency('http://github.com/foo/bar');
      dependencyLocal = new Dependency('path/to/repo');
      expect(dependencyRemoteSsh.remote).to.be(true);
      expect(dependencyRemoteHttp.remote).to.be(true);
      expect(dependencyLocal.remote).to.be(false);
      return done();
    });
    it('sets treeish to master by default', function(done) {
      var dependency;

      dependency = new Dependency('http://github.com/foo/bar');
      expect(dependency.treeish).to.eql('master');
      return done();
    });
    return it('sets a treeish', function(done) {
      var branchTreeish, commitTreeish, remoteBranchTreeish, remoteCommitTreeish;

      commitTreeish = new Dependency('../some_dir/parachute#bdfbd80');
      branchTreeish = new Dependency('../some_dir/parachute#some-branch');
      remoteCommitTreeish = new Dependency('https://github.com/crowdtap/parachute.git#bdfbd80');
      remoteBranchTreeish = new Dependency('https://github.com/crowdtap/parachute.git#some-branch');
      expect(commitTreeish.treeish).to.eql('bdfbd80');
      expect(branchTreeish.treeish).to.eql('some-branch');
      expect(remoteCommitTreeish.treeish).to.eql('origin/bdfbd80');
      expect(remoteBranchTreeish.treeish).to.eql('origin/some-branch');
      return done();
    });
  });
  describe('#cache', function() {
    it('returns a promise', function(done) {
      var dependency, gitOrig, gitStub;

      dependency = new Dependency('foo');
      gitStub = sinon.stub().returns({
        then: function() {
          return true;
        }
      });
      gitOrig = Dependency.__get__('git');
      Dependency.__set__({
        git: gitStub
      });
      expect(dependency.cache().toString()).to.be('[object Promise]');
      Dependency.__set__({
        git: gitOrig
      });
      return done();
    });
    it('clones local source repos into the cache directory', function(done) {
      var dependency, gitOrig, gitStub, src;

      src = '../localDirectory/repo.git#some-branch';
      dependency = new Dependency(src);
      gitStub = sinon.stub().returns({
        then: function() {
          return true;
        }
      });
      gitOrig = Dependency.__get__('git');
      Dependency.__set__({
        git: gitStub
      });
      dependency.cache();
      expect(gitStub.calledWith(['clone', path.resolve(src.split('#')[0]), dependency.cacheDir])).to.be(true);
      Dependency.__set__({
        git: gitOrig
      });
      return done();
    });
    it('clones remote source repos into the cache directory', function(done) {
      var dependency, gitOrig, gitStub, src;

      src = 'https://github.com/user/repo.git#some-branch';
      dependency = new Dependency(src);
      gitStub = sinon.stub().returns({
        then: function() {
          return true;
        }
      });
      gitOrig = Dependency.__get__('git');
      Dependency.__set__({
        git: gitStub
      });
      dependency.cache();
      expect(gitStub.calledWith(['clone', src.split('#')[0], dependency.cacheDir])).to.be(true);
      Dependency.__set__({
        git: gitOrig
      });
      return done();
    });
    return it('clones the dependency source into the cache directory', function(done) {
      var dependency;

      dependency = new Dependency('../repos/without_json');
      expect(fs.existsSync("" + process.env['HOME'] + "/.parachute/repos-without_json")).to.be(false);
      return dependency.cache().then(function() {
        expect(fs.existsSync("" + process.env['HOME'] + "/.parachute/repos-without_json")).to.be(true);
        return done();
      });
    });
  });
  return describe('#copy', function() {
    it('returns an error if dependency cache is dirty', function(done) {
      var dependency;

      dependency = new Dependency('../repos/without_json');
      return dependency.cache().then(function() {
        dependency.on('error', function(err) {
          expect(err.message).to.eql('dependency cache is dirty');
          return done();
        });
        fs.unlinkSync("" + process.env['HOME'] + "/.parachute/repos-without_json/should-copy.txt");
        return dependency.copy();
      });
    });
    it('does not copy ignored files from cache', function(done) {
      var dependency;

      dependency = new Dependency('../repos/without_json');
      dependency.on('error', function(err) {
        throw err;
      });
      return dependency.cache().then(function() {
        return dependency.copy().then(function() {
          expect(fs.existsSync("" + (process.cwd()) + "/.git")).to.be(false);
          return done();
        });
      });
    });
    it('checks out the treeish before copying', function(done) {
      var dependency, gitOrig, gitStub;

      dependency = new Dependency('https://github.com/user/repo.git#some-branch');
      dependency.repo = {
        status: function() {}
      };
      sinon.stub(dependency, 'isCached', function() {
        return true;
      });
      sinon.stub(dependency, 'copyComponents', function() {
        return true;
      });
      sinon.stub(dependency.repo, 'status', function(callback) {
        return callback(false, {
          clean: true
        });
      });
      gitStub = sinon.stub().returns({
        then: function() {
          return true;
        }
      });
      gitOrig = Dependency.__get__('git');
      Dependency.__set__({
        git: gitStub
      });
      dependency.copy();
      expect(gitStub.calledWith(['checkout', 'origin/some-branch'], {
        cwd: dependency.cacheDir
      })).to.be(true);
      Dependency.__set__({
        git: gitOrig
      });
      return done();
    });
    it('restores the cache to the master branch after copy', function(done) {
      var dependency, gitOrig, gitStub;

      dependency = new Dependency('https://github.com/user/repo.git#v1.0.0');
      dependency.repo = {
        status: function() {}
      };
      sinon.stub(dependency, 'isCached', function() {
        return true;
      });
      sinon.stub(dependency, 'copyComponents', function(cb) {
        return cb();
      });
      sinon.stub(dependency.repo, 'status', function(callback) {
        return callback(false, {
          clean: true
        });
      });
      gitStub = sinon.stub().returns({
        then: function(cb) {
          return cb();
        }
      });
      gitOrig = Dependency.__get__('git');
      Dependency.__set__({
        git: gitStub
      });
      dependency.copy();
      expect(gitStub.lastCall.calledWith(['checkout', 'master'], {
        cwd: dependency.cacheDir
      })).to.be(true);
      Dependency.__set__({
        git: gitOrig
      });
      return done();
    });
    it('allows a set of variable interpolation within parachute.json', function(done) {
      var dependency;

      dependency = new Dependency('../repos/with_variables');
      dependency.on('error', function(err) {
        throw err;
      });
      return dependency.cache().then(function() {
        return dependency.copy().then(function() {
          expect(fs.existsSync("css/install_test/core.css")).to.be(true);
          return done();
        });
      });
    });
    it('allows a start of the year date variable interpolation within parachute.json', function(done) {
      var dependency;

      dependency = new Dependency('../repos/with_variables');
      dependency.on('error', function(err) {
        throw err;
      });
      timekeeper.travel(new Date(2013, 0, 1));
      return dependency.cache().then(function() {
        return dependency.copy().then(function() {
          expect(fs.existsSync("css/colors-2013-01-01.css")).to.be(true);
          expect(fs.existsSync("css/fonts-2013-01-01.css")).to.be(true);
          return done();
        });
      });
    });
    it('allows an end of the year date variable interpolation within parachute.json', function(done) {
      var dependency;

      dependency = new Dependency('../repos/with_variables');
      dependency.on('error', function(err) {
        throw err;
      });
      timekeeper.travel(new Date(2013, 11, 31));
      return dependency.cache().then(function() {
        return dependency.copy().then(function() {
          expect(fs.existsSync("css/colors-2013-12-31.css")).to.be(true);
          expect(fs.existsSync("css/fonts-2013-12-31.css")).to.be(true);
          return done();
        });
      });
    });
    describe('source parachute.json components option', function() {
      it('copies all cache contents if no source parachute.json exists', function(done) {
        var dependency;

        dependency = new Dependency('../repos/without_json');
        dependency.on('error', function(err) {
          throw err;
        });
        return dependency.cache().then(function() {
          return dependency.copy().then(function() {
            expect(fs.existsSync('should-copy.txt')).to.be(true);
            expect(fs.existsSync('css/core.css')).to.be(true);
            return done();
          });
        });
      });
      return it('copies cache contents according to parachute.json when present', function(done) {
        var dependency;

        dependency = new Dependency('../repos/with_json');
        dependency.on('error', function(err) {
          throw err;
        });
        return dependency.cache().then(function() {
          return dependency.copy().then(function() {
            expect(fs.existsSync('should-not-copy.txt')).to.be(false);
            expect(fs.existsSync('css/core.css')).to.be(false);
            expect(fs.existsSync('css/shared/core.css')).to.be(true);
            return done();
          });
        });
      });
    });
    return describe('local parachute.json components option', function() {
      it('copies filenames indicated in components option', function(done) {
        var dependency;

        dependency = new Dependency('../repos/without_json', {
          components: ['css/core.css']
        });
        dependency.on('error', function(err) {
          throw err;
        });
        return dependency.cache().then(function() {
          return dependency.copy().then(function() {
            expect(fs.existsSync('core.css')).to.be(true);
            expect(fs.existsSync('should-copy.txt')).to.be(false);
            return done();
          });
        });
      });
      return it('copies file objects indicated in components option', function(done) {
        var components, dependency;

        components = [
          {
            src: 'css/core.css',
            dest: 'css/shared/core.css'
          }
        ];
        dependency = new Dependency('../repos/without_json', {
          components: components
        });
        dependency.on('error', function(err) {
          throw err;
        });
        return dependency.cache().then(function() {
          return dependency.copy().then(function() {
            expect(fs.existsSync('css/shared/core.css')).to.be(true);
            expect(fs.existsSync('should-copy.txt')).to.be(false);
            return done();
          });
        });
      });
    });
  });
});
