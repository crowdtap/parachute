// Generated by CoffeeScript 1.6.2
var Dependency, EventEmitter, assetVars, copycat, fs, gift, git, path, spawn, template, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

EventEmitter = require('events').EventEmitter;

assetVars = require('./asset_vars');

copycat = require('../util/copycat');

git = require('../util/git-wrapper');

template = require('../util/template');

_ = require('../util/lodash-ext');

fs = require('fs');

gift = require('gift');

path = require('path');

spawn = require('child_process').spawn;

Dependency = (function(_super) {
  __extends(Dependency, _super);

  function Dependency(src, options) {
    var gitRegex, pathSegments;

    this.src = src;
    gitRegex = /(\w+:\/\/)?(.+@)*([\w\d\.]+):?\/*(.*)/;
    pathSegments = this.src.match(gitRegex);
    this.name = pathSegments[4].replace('/', '-').replace('.git', '');
    this.cacheDir = path.join(process.env['HOME'], '.parachute', this.name);
    this.root = (options != null ? options.root : void 0) || process.cwd();
    this.remote = (pathSegments[1] != null) || (pathSegments[2] != null);
    if (!this.remote) {
      this.src = path.resolve(this.src);
    }
    this.repo = gift(this.cacheDir);
    this.components = (options != null ? options.components : void 0) && this.parseComponents(options.components);
    this.ncpOptions = {
      clobber: true,
      filter: function(filename) {
        var ignore;

        ignore = [/\.git/, /parachute.json/, /post_scripts/];
        return !_.detect(ignore, function(regexp) {
          var _ref;

          return (_ref = filename.match(regexp)) != null ? _ref.length : void 0;
        });
      }
    };
  }

  Dependency.prototype.cache = function(cb) {
    var cp,
      _this = this;

    template('action', {
      doing: 'caching',
      what: this.src
    }).on('data', this.emit.bind(this, 'data'));
    cp = git(['clone', this.src, this.cacheDir]);
    return cp.on('exit', function(status) {
      _this.emit('cached', status);
      return typeof cb === "function" ? cb(status) : void 0;
    });
  };

  Dependency.prototype.copy = function(cb) {
    var _this = this;

    if (this.isCached()) {
      return this.repo.status(function(err, status) {
        if (status.clean) {
          _this.copyComponents(cb);
          return template('action', {
            doing: 'copying',
            what: _this.src
          }).on('data', _this.emit.bind(_this, 'data'));
        } else {
          return _this.emit('error', {
            message: 'dependency cache is dirty'
          });
        }
      });
    } else {
      return this.emit('error', {
        message: 'dependency is not cached'
      });
    }
  };

  Dependency.prototype.isCached = function() {
    return fs.existsSync(this.cacheDir);
  };

  Dependency.prototype.update = function(cb) {
    var _this = this;

    return this.repo.status(function(err, status) {
      var cp;

      if (status.clean) {
        template('action', {
          doing: 'Updating',
          what: _this.name
        }).on('data', _this.emit.bind(_this, 'data'));
        cp = git(['pull', 'origin', 'master'], {
          cwd: _this.cacheDir
        });
        return cp.on('exit', function(status) {
          _this.emit('updated', status);
          return typeof cb === "function" ? cb() : void 0;
        });
      } else {
        return _this.emit('error', {
          message: "'" + _this.name + "' repo is dirty, please resolve changes"
        });
      }
    });
  };

  Dependency.prototype.parseComponents = function(components) {
    return _.map(components, function(item) {
      if (typeof item === 'string') {
        return {
          src: item,
          dest: null
        };
      } else {
        return item;
      }
    });
  };

  Dependency.prototype.sourceComponents = function() {
    if (fs.existsSync("" + this.cacheDir + "/parachute.json")) {
      return JSON.parse(fs.readFileSync("" + this.cacheDir + "/parachute.json")).components;
    }
  };

  Dependency.prototype.copyComponents = function(cb) {
    var components, copyNextComponent, next,
      _this = this;

    components = this.components || this.sourceComponents() || [
      {
        src: null,
        dest: null
      }
    ];
    components = _.map(components, function(component) {
      var componentWithAbsPaths;

      return componentWithAbsPaths = {
        src: path.join(_this.cacheDir, component.src || ''),
        dest: path.join(_this.root, component.dest || '')
      };
    });
    if (components != null ? components.length : void 0) {
      next = function(err) {
        if (err) {
          throw err;
        }
        if (components.length) {
          return copyNextComponent();
        } else {
          _this.emit('copied', 0);
          return typeof cb === "function" ? cb(0) : void 0;
        }
      };
      return (copyNextComponent = function() {
        var component;

        component = components.shift();
        return copycat.copy(component.src, _this.subVariables(component.dest), _this.ncpOptions, next);
      })();
    }
  };

  Dependency.prototype.subVariables = function(string) {
    var key, variable, _i, _len, _ref;

    _ref = string.match(/{{(\w+)}}/g) || [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      variable = _ref[_i];
      key = variable.slice(2, -2);
      string = string.replace(variable, assetVars[key]);
    }
    return string;
  };

  return Dependency;

})(EventEmitter);

module.exports = Dependency;
